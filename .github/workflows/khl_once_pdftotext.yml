name: KHL PDF → JSON (pdftotext)

on:
  workflow_dispatch:
    inputs:
      uid:
        description: "KHL match UID"
        required: true
        default: "897694"
      season:
        description: "KHL season code"
        required: true
        default: "1369"

permissions:
  contents: read
  pages: write
  id-token: write

env:
  UID: ${{ inputs.uid }}
  SEASON: ${{ inputs.season }}
  OUT_DIR: public/khl/json

jobs:
  run:
    runs-on: ubuntu-latest

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: "3.11"

      - name: Install poppler-utils (pdftotext)
        run: |
          sudo apt-get update
          sudo apt-get install -y poppler-utils

      - name: Fetch PDF
        shell: bash
        run: |
          set -e
          mkdir -p /tmp
          UA="Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/122.0.0.0 Safari/537.36"
          PDF_URL="https://khl.ru/pdf/${SEASON}/${UID}/game-${UID}-start-ru.pdf"
          echo "[INFO] GET ${PDF_URL}"
          curl -sSL --http2 --fail \
            -H "Accept: application/pdf,application/octet-stream;q=0.9,*/*;q=0.8" \
            -H "Accept-Language: ru,en;q=0.9" \
            -H "Referer: https://khl.ru/" \
            -H "User-Agent: ${UA}" \
            -o /tmp/game.pdf "${PDF_URL}"
          ls -l /tmp/game.pdf

      - name: pdftotext -layout
        shell: bash
        run: |
          set -e
          pdftotext -layout -nopgbrk /tmp/game.pdf /tmp/game.txt
          echo "===== HEAD 40 ====="
          head -n 40 /tmp/game.txt | nl -ba
          echo "===== TAIL 80 ====="
          tail -n 80 /tmp/game.txt | nl -ba

      - name: Parse → JSON (teams / date / time / referees / goalies)
        shell: bash
        run: |
          set -e
          mkdir -p "$OUT_DIR"
          mkdir -p public/khl/raw

          python - <<'PY'
          import os, re, json, unicodedata, pathlib

          UID = int(os.environ["UID"])
          OUT_DIR = os.environ["OUT_DIR"]

          raw_path = pathlib.Path("/tmp/game.txt")
          raw_text = raw_path.read_text(encoding="utf-8", errors="ignore")
          raw_lines = [ln.rstrip("\n\r") for ln in raw_text.splitlines()]

          def strip_acc(s: str) -> str:
              s = unicodedata.normalize("NFKD", s)
              return "".join(ch for ch in s if unicodedata.category(ch) != "Mn")

          def norm_line(s: str) -> str:
              s = s.replace("\xa0"," ").replace("\u2009"," ").replace("\u202f"," ")
              s = re.sub(r"[ \t]+"," ", s).strip()
              return strip_acc(s)

          norm_lines = [norm_line(x) for x in raw_lines]
          full_norm = "\n".join(norm_lines)

          # date / time
          m_date = re.search(r"(\d{2})[./-](\d{2})[./-](\d{4})", full_norm)
          date = f"{m_date.group(1)}.{m_date.group(2)}.{m_date.group(3)}" if m_date else None
          m_time = re.search(r"(\d{2}:\d{2})\s*MSK", full_norm, re.I)
          time_msk = m_time.group(1) if m_time else None

          # teams: строка сразу после "Матч №"
          teams = [None, None]
          try:
              i_match = next(i for i, ln in enumerate(norm_lines) if re.search(r"^Матч\s*№\s*\d+", ln))
              raw_after = raw_lines[i_match+1] if i_match+1 < len(raw_lines) else ""
              parts = [p.strip(' "«»') for p in re.split(r"\s{2,}", raw_after) if p.strip()]
              if len(parts) >= 2:
                  teams = [parts[0], parts[-1]]
          except StopIteration:
              pass

          # referees: ищем маркеры ролей, берём следующую строку
          main_refs, linesmen = [], []
          for i, ln in enumerate(norm_lines):
              if re.search(r"Главный судья.*Линейн\w+ судья", ln, re.I):
                  if i + 1 < len(raw_lines):
                      cols = [c.strip() for c in re.split(r"\s{2,}", raw_lines[i+1]) if c.strip()]
                      if len(cols) >= 4:
                          main_refs = cols[0:2]
                          linesmen  = cols[2:4]
                  break

          # goalies: блок "Вратари    Вратари", читаем 1-3 строк ниже
          goal = {"home": [], "away": []}

          def parse_goal_cell(text: str):
              text = re.sub(r"\s+\d{2}\.\d{2}\.\d{4}\s+\d{1,2}\s*$", "", text)
              m = re.match(r"\s*(\d{1,2})\s*В\s+(.*)$", text)
              if not m: return None
              num = int(m.group(1)); tail = m.group(2).strip()
              status = ""
              if re.search(r"\bС\b", tail): status = "starter"; tail = re.sub(r"\bС\b", "", tail)
              elif re.search(r"\bР\b", tail): status = "reserve"; tail = re.sub(r"\bР\b", "", tail)
              toks = [t for t in tail.split() if t]
              name = " ".join(toks[:2]) if len(toks) >= 2 else tail
              return {"number": num, "name": name, "status": status}

          i_vr = None
          for i, ln in enumerate(norm_lines):
              if re.search(r"\bВратари\b\s+\bВратари\b", ln, re.I):
                  i_vr = i
                  break

          if i_vr is not None:
              for row in raw_lines[i_vr+1 : min(i_vr+4, len(raw_lines))]:
                  cols = [c for c in re.split(r"\s{2,}", row) if c.strip()]
                  if len(cols) >= 2:
                      L = parse_goal_cell(cols[0])
                      R = parse_goal_cell(cols[-1])
                      if L: goal["home"].append(L)
                      if R: goal["away"].append(R)

          out = {
              "ok": True,
              "uid": UID,
              "data": {
                  "teams": teams,
                  "date": date,
                  "time_msk": time_msk,
                  "main_referees": main_refs,
                  "linesmen": linesmen,
                  "goalies": goal,
              },
          }

          out_dir = pathlib.Path(OUT_DIR)
          out_dir.mkdir(parents=True, exist_ok=True)
          (out_dir / f"{UID}.json").write_text(json.dumps(out, ensure_ascii=False, indent=2), encoding="utf-8")

          raw_dir = pathlib.Path("public/khl/raw")
          raw_dir.mkdir(parents=True, exist_ok=True)
          (raw_dir / f"{UID}_game.txt").write_text(raw_text, encoding="utf-8")
          (raw_dir / f"{UID}_lines.json").write_text(json.dumps(raw_lines[:200], ensure_ascii=False, indent=2), encoding="utf-8")

          print("OK: wrote JSON and RAW dumps")
          PY

      - name: Show TREE of public
        shell: bash
        run: |
          echo "--- TREE public"
          find public -maxdepth 3 -type f -print | sort || true

      - name: Upload artifact (Pages)
        uses: actions/upload-pages-artifact@v3
        with:
          path: public

      - name: Deploy to Pages
        id: deployment
        uses: actions/deploy-pages@v4
